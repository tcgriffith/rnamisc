#' Title dot bracket notation to a list of pairs
#'
#' @param ss sequence
#'
#' @return a list of pairs
#' @import seqinr
#' @export
#'
#' @examples
#' rnamisc::dot2pair("((..))")
dot2pair = function(ss){
  ss.c = seqinr::s2c(ss)
  plist = list()
  stack = integer()
  for (i in 1:length(ss.c)){
    if (ss.c[[i]] %in% c(".","-")){

    }
    if (ss.c[[i]] %in% c("(")){
      stack = append(stack, i)
    }
    if (ss.c[[i]] %in% c(")")){
      plist = append(plist,list(c(tail(stack,1),i)))
      stack = stack[-length(stack)]
    }
  }
  return(plist)
}




#' Read SS pairs in json, generated by x3dna-dssar
#'
#' @param x either a json string or path to the json formatted SS file
#' @param paironly default FALSE, if TRUE, return pair positions
#'
#' @return a dataframe of SS pairs
#'
#' @import jsonlite
#' @import dplyr
#' @export
#'
read_dssr = function(x, paironly=FALSE) {
  if (jsonlite::validate(x)){
    test = jsonlite::parse_json(x)
  }
  else{
    test = jsonlite::read_json(x)
  }

  if (test$num_pairs ==0){
    return(NULL)
  }

  df = do.call(rbind, lapply(test$pairs, as.data.frame)) %>%
    mutate(pos1 = gsub(".*?(\\d+).*","\\1",nt1),
           pos2 = gsub(".*?(\\d+).*","\\1",nt2))

  if (paironly){
    return(df[,c(pos1,pos2)])
  }



  return(df)
}
